// 숨바꼭질 6 성공 Silver I
// 유클리드 호제법수학정수론
// 난이도 제공: solved.ac — 난이도 투표하러 가기
// 시간 제한	메모리 제한	제출	정답	맞은 사람	정답 비율
// 1 초	512 MB	1532	768	624	50.040%
// 문제
// 수빈이는 동생 N명과 숨바꼭질을 하고 있다. 수빈이는 현재 점 S에 있고, 동생은 A1, A2, ..., AN에 있다.

// 수빈이는 걸어서 이동을 할 수 있다. 수빈이의 위치가 X일때 걷는다면 1초 후에 X+D나 X-D로 이동할 수 있다. 수빈이의 위치가 동생이 있는 위치와 같으면, 동생을 찾았다고 한다.

// 모든 동생을 찾기위해 D의 값을 정하려고 한다. 가능한 D의 최댓값을 구해보자.

// 입력
// 첫째 줄에 N(1 ≤ N ≤ 105)과 S(1 ≤ S ≤ 109)가 주어진다. 둘째 줄에 동생의 위치 Ai(1 ≤ Ai ≤ 109)가 주어진다. 동생의 위치는 모두 다르며, 수빈이의 위치와 같지 않다.

// 출력
// 가능한 D값의 최댓값을 출력한다.

// 예제 입력 1 
// 3 3
// 1 7 11
// 예제 출력 1 
// 2
// 예제 입력 2 
// 3 81
// 33 105 57
// 예제 출력 2 
// 24
// 예제 입력 3 
// 1 1
// 1000000000
// 예제 출력 3 
// 999999999

#include <iostream>
//#include <cstdlib>
#include <algorithm>
#include <vector>

using namespace std;

int gcd(int a, int b){
    if(b == 0)
        return a;
    else{
        return gcd(b, a%b);
    }
}

int main()
{
    int a[100000];
    int D[100000];
    
    int N;
    int S;
    cin>>N>>S;
//    vector<int> a(N);
//    vector<int> D(N);
    
    for(int i=0; i<N; i++){
        cin>>a[i];
    }
    
    for(int i=0; i<N; i++){
        D[i] = abs(S - a[i]);
    }
    
    int result = D[0];
    
    for(int i=1; i<N; i++){
        result = gcd(result, D[i]);
    }

    cout<<result<<'\n';
    
    return 0;
}

// N(동생수) 입력, S입력 (현재위치)
// 그다음 N1 N2 N3 ...

// S(현재점)과의 차이를 보고, 그 차이들에서 ,
// 2 4 4. >> 최대공약수 2칸
// 48 24 24 >> 최대공약수 24칸
// 9999999 >> 최대공약수 9999999
// 만약에 차이가 3 4 9 이런거면 최대공약수1


// 거리의 차이를 구하고, 그것들의 최대공약수를 구하는 문제였다.

// 처음에 배열 10000으로 해서 실패, 10^5 = 100000 이므로 100000으로 수정해서 성공.
// 아니면 vector로 선언해도 성공이 출력됨
