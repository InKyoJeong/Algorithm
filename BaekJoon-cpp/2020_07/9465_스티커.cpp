//스티커 성공출처다국어분류 Silver II
//다이나믹 프로그래밍
//난이도 제공: solved.ac — 난이도 투표하러 가기
//시간 제한    메모리 제한    제출    정답    맞은 사람    정답 비율
//1 초    256 MB    29174    14638    9538    48.468%
//문제
//상근이의 여동생 상냥이는 문방구에서 스티커 2n개를 구매했다. 스티커는 그림 (a)와 같이 2행 n열로 배치되어 있다. 상냥이는 스티커를 이용해 책상을 꾸미려고 한다.
//
//상냥이가 구매한 스티커의 품질은 매우 좋지 않다. 스티커 한 장을 떼면, 그 스티커와 변을 공유하는 스티커는 모두 찢어져서 사용할 수 없게 된다. 즉, 뗀 스티커의 왼쪽, 오른쪽, 위, 아래에 있는 스티커는 사용할 수 없게 된다.
//
//
//
//모든 스티커를 붙일 수 없게된 상냥이는 각 스티커에 점수를 매기고, 점수의 합이 최대가 되게 스티커를 떼어내려고 한다. 먼저, 그림 (b)와 같이 각 스티커에 점수를 매겼다. 상냥이가 뗄 수 있는 스티커의 점수의 최댓값을 구하는 프로그램을 작성하시오. 즉, 2n개의 스티커 중에서 점수의 합이 최대가 되면서 서로 변을 공유 하지 않는 스티커 집합을 구해야 한다.
//
//위의 그림의 경우에 점수가 50, 50, 100, 60인 스티커를 고르면, 점수는 260이 되고 이 것이 최대 점수이다. 가장 높은 점수를 가지는 두 스티커 (100과 70)은 변을 공유하기 때문에, 동시에 뗄 수 없다.
//
//입력
//첫째 줄에 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스의 첫째 줄에는 n (1 ≤ n ≤ 100,000)이 주어진다. 다음 두 줄에는 n개의 정수가 주어지며, 각 정수는 그 위치에 해당하는 스티커의 점수이다. 연속하는 두 정수 사이에는 빈 칸이 하나 있다. 점수는 0보다 크거나 같고, 100보다 작거나 같은 정수이다.
//
//출력
//각 테스트 케이스 마다, 2n개의 스티커 중에서 두 변을 공유하지 않는 스티커 점수의 최댓값을 출력한다.
//
//예제 입력 1
//2
//5
//50 10 100 20 40
//30 50 70 10 60
//7
//10 30 10 50 100 20 40
//20 40 30 50 60 20 80
//예제 출력 1
//260
//290

#include <iostream>

using namespace std;
long long p[100000][2];
long long d[100000][2];
int main()
{
    int t;
    cin>>t;
    while(t--){
        int n;
        cin>>n;
        for(int i=0; i<=1; i++){
            for(int j=1; j<=n; j++){
                cin>>p[j][i];
            }
        }

        d[1][0] = p[1][0];
        d[1][1] = p[1][1];

        for(int i=2; i<=n; i++){
            d[i][0] = max( d[i-1][1] + p[i][0] , d[i-2][1] + p[i][0] );
            d[i][1] = max( d[i-1][0] + p[i][1] , d[i-2][0] + p[i][1] );
        }
        cout<<max(d[n][0] , d[n][1])<<'\n';
        
    }
    return 0;
}

//내생각
//        p는 입력값
//        1 0  2 0  3 0
//        1 1  2 1  3 1 ... 순서로 입력 받아서
       
//        d[n][j] : 2*n개에서 최대점수. 마지막에 j뜯은경우
//             j : 0은 첫번째칸, 1은 두번째칸

//        2*1 경우,
//        d[1][0] = p[1][0];    첫번째칸 뜯은점수
//        d[1][1] = p[1][1];    두번째칸 뜯은점수


//        2*2 경우,
//        마지막에 첫번째칸을 뜯은경우 점수
//        d[2][0] = d[1][1] + p[2][0];
//        마지막에 두번째칸을 뜯은경우 점수
//        d[2][1] = d[1][0] + p[2][1];

//        max(d[2][0], d[2][1])    이게 최종적으로 2*2중 최대점수


//        2*3 경우 부터는 한칸띄고 뜯을수있어서
//        d[3][0] = d[1][1] + p[3][0] 도 가능

// 따라서
//        2*n 경우,
//        d[n][0] =  max( d[n][1] + p[n][0] , d[n-2][1] + p[n][0] )
//        d[n][1] =  max( d[n][0] + p[n][1] , d[n-2][0] + p[n][1] )
        


//다른(백준)풀이
// d[i][j] : 2*i에서 최대점수. i번열에서 뜯은 스티커는 j
// j=0은 뜯지않음, 1은 위쪽뜯음, 2는 아래쪽뜯음
#include <iostream>
#include <algorithm>
using namespace std;
long long a[100001][2];
long long d[100001][3];
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
    int t;
    cin >> t;
    while(t--) {
        int n;
        cin >> n;
        for (int i=1; i<=n; i++) {
            cin >> a[i][0];
        }
        for (int i=1; i<=n; i++) {
            cin >> a[i][1];
        }
        d[0][0] = d[0][1] = d[0][2] = 0;
        for (int i=1; i<=n; i++) {
            d[i][0] = max({d[i-1][0],d[i-1][1],d[i-1][2]});
            d[i][1] = max(d[i-1][0],d[i-1][2])+a[i][0];
            d[i][2] = max(d[i-1][0],d[i-1][1])+a[i][1];
        }
        long long ans = max({d[n][0], d[n][1], d[n][2]});
        cout << ans << '\n';
    }
    return 0;
}