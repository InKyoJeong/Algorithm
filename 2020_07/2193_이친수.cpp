// 이친수 성공분류 Silver III
// 다이나믹 프로그래밍
// 난이도 제공: solved.ac — 난이도 투표하러 가기
// 시간 제한	메모리 제한	제출	정답	맞은 사람	정답 비율
// 2 초	128 MB	49683	19473	14503	37.422%
// 문제
// 0과 1로만 이루어진 수를 이진수라 한다. 이러한 이진수 중 특별한 성질을 갖는 것들이 있는데, 이들을 이친수(pinary number)라 한다. 이친수는 다음의 성질을 만족한다.

// 이친수는 0으로 시작하지 않는다.
// 이친수에서는 1이 두 번 연속으로 나타나지 않는다. 즉, 11을 부분 문자열로 갖지 않는다.
// 예를 들면 1, 10, 100, 101, 1000, 1001 등이 이친수가 된다. 하지만 0010101이나 101101은 각각 1, 2번 규칙에 위배되므로 이친수가 아니다.

// N(1 ≤ N ≤ 90)이 주어졌을 때, N자리 이친수의 개수를 구하는 프로그램을 작성하시오.

// 입력
// 첫째 줄에 N이 주어진다.

// 출력
// 첫째 줄에 N자리 이친수의 개수를 출력한다.

// 예제 입력 1 
// 3
// 예제 출력 1 
// 2
//--------------------------------------------


// 생각
// d[i][j]
// i자리크기 일때, 마지막에j 가 오는 개수
// d[i][0] 일때:  d[i-1][0] + d[i-1][1]
// d[i][1] 일떄:  d[i-1][0]

// 예외: n자리에 있는 수가 0이면 안된다.
// 즉, d[1][1] = 1
//     d[1][0] = 0
// 즉, d[2][1] = 0
//    d[2][0] = 1

//cf) d[2][1] 과 d[2][0]은 초기화할필요 없었다.

#include <iostream>
using namespace std;

long long d[91][2];
int main(){
    int n;
    cin>>n;
    for(int i=1; i<=n; i++){
        for(int j=0; j<=1; j++){
            d[1][1] = 1;
            d[1][0] = 0;
            if(j==0){
                d[i][0] += d[i-1][0] + d[i-1][1];
            }else{
                d[i][1] += d[i-1][0];
            }
        }
    }
    cout<<d[n][0]+d[n][1]<<'\n';
    return 0;
}

// 생각해보니 이중for문이 필요없었다.
// 고쳐본 더짧은 풀이
#include <iostream>
using namespace std;

long long d[91][2];
int main(){
    int n;
    cin>>n;

    d[1][1] = 1;
    d[1][0] = 0;
    for(int i=2; i<=n; i++){
        d[i][0] = d[i-1][0] + d[i-1][1];
        d[i][1] = d[i-1][0];
        }
    
    cout<<d[n][0]+d[n][1]<<'\n';
    return 0;
}



// 1차원 다이나믹으로 해결한 풀이
#include <iostream>
using namespace std;

long long d[91];
int main() {
    int n;
    cin >> n;
    d[1] = 1;
    d[2] = 1;
    for (int i=3; i<=n; i++) {
        d[i] = d[i-1] + d[i-2];
    }
    cout << d[n] << '\n';
    return 0;
}

// d[n]  =  n자리 이친수 라고 생각

// 마지막수 0 인경우
// 0으로 끝났으면 앞에는 0도 되고 1도 되므로
// d[n-1]자리 이친수를 만들고 거기에 0을 붙이면 d[n]

// 마지막수 1 인경우
// 1로 끝났으면 앞에는 0만 되고 앞의앞에는 0과1이 되므로
// 1은 반드시 앞에 0만 오므로 
// d[n-1] , d[n] 둘을 묶어서 생각
// 이경우 d[n-2]

// 즉, d[n] = d[n-1] + d[n-2] 이다.




//https://m.blog.naver.com/PostView.nhn?blogId=occidere&logNo=220788046159&proxyReferer=https:%2F%2Fwww.google.com%2F
// d[N] = d[N-2] + d[N-1]이다. 즉, 피보나치 수 이다
//n=1일때    1
//n=2일때    "10"
//n=3일때    1"00" 1"01"
//n=4일때    10"00" 10"01" 10"10"
